# CVE-2018-21000

## Source

```rust
use std::mem::{size_of, forget};
use std::vec::Vec;

pub unsafe fn guarded_transmute_vec_permissive<T>(mut bytes: Vec<u8>) -> Vec<T> {
    // PermissiveGuard::check::<T>(&bytes).unwrap();
    let ptr = bytes.as_mut_ptr();
    let capacity = bytes.capacity() / size_of::<T>();
    let len = bytes.len() / size_of::<T>();
    forget(bytes);
    Vec::from_raw_parts(ptr as *mut T, capacity, len)
}

pub unsafe fn guarded_transmute_to_bytes_vec<T>(mut from: Vec<T>) -> Vec<u8> {
    let capacity = from.capacity() * size_of::<T>();
    let len = from.len() * size_of::<T>();
    let ptr = from.as_mut_ptr();
    forget(from);
    Vec::from_raw_parts(ptr as *mut u8, capacity, len)
}
```

## Function Signature

```rust
pub unsafe fn from_raw_parts(
    ptr: *mut T,
    length: usize,
    capacity: usize
) -> Vec<T>
```

## Related Safe Property

The `Vec::from_raw_parts` function has the following safety properties:

1. `ptr` must have been allocated using the global allocator, such as via the `alloc::alloc` function.
2. `T` needs to have the same alignment as what `ptr` was allocated with. 
3. The size of `T` times the capacity (ie. the allocated size in bytes) needs to be the same size as the pointer was allocated with.
4. length needs to be less than or equal to capacity.
5. The ownership of `ptr` is effectively transferred to the Vec<T> at will. Ensure that nothing else uses the pointer after calling this function.

## Pattern Description

The pattern focuses on functions which convert the underlying data type of a vector in an unsafe context. So the following safe properties are naturally satisfied:

1. The `ptr` is allocated using the global allocator, cause it is allocated by the original `Vec` object.
2. The alignment of `T` is the same as the original `Vec` object.
3. The size of `T` times the capacity which is properly calculated should be the same size as the pointer was allocated with.

However, the following safe properties can be probably violated:

4. The length of the new `Vec` object is less than or equal to the capacity. User can violate
this property by reversing the position of `length` and `capacity` accidentally when calling the `Vec::from_raw_parts` function.
1. The ownership of `ptr` is effectively transferred to the new `Vec` object. User can still use the pointer after calling this function, or forget to use the `forget` function to manually drop the original `ptr`.

So there are two predicates, which respectively correspond to the two safe properties that can be violated:

1. `ReversedParameter` focused on the reversed length and capacity passed to the `Vec::from_raw_parts` function.
2. `WithoutForget` focused on the missing of calling the `forget` function on the original `ptr`.