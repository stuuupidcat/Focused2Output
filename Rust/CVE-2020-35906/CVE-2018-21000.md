# CVE-2018-21000

## Source

```rust
pub fn waker<W>(wake: Arc<W>) -> core::task::Waker
where
    // bug fix: 
    // W: ArcWake + 'static
    W: ArcWake,
{
    let ptr = Arc::into_raw(wake) as *const ();

    unsafe {
        Waker::from_raw(RawWaker::new(ptr, waker_vtable::<W>()))
    }
}
```

```rust
pub trait ArcWake: Send + Sync {
    fn wake(self: Arc<Self>) {
        Self::wake_by_ref(&self)
    }

    fn wake_by_ref(arc_self: &Arc<Self>);
}
```

## Function Signature

N/A

## Related Safe Property

Outliving/Thread, i.e. lifetime issues.

## Pattern Description

The pattern focuses on functions which convert an `Arc<W>` object to a `core::task::Waker` object. The `ArcWake` trait is used to define the `wake` and `wake_by_ref` function, which is called by `waker_vtable` function to create the vtable(bahaviors) of the `core::task::Waker` object.

However, when you wish to convert an `Arc<W>` object into a `core::task::Waker` object and ensure it can wake up tasks as expected across different threads, you need to ensure that `W` has a `'static` lifetime constraint. This is because the `Waker` might be invoked from different threads, and it needs to ensure that the referenced object remains valid throughout the lifetimes of all associated threads.

So there is one predicate `WakerGeneratorWithoutStatic` in the pattern file, it captures the case where the `W` object does not have a `'static` lifetime constraint.