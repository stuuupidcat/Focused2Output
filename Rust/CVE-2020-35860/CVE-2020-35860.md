# CVE-2020-35860

## Source

```rust
extern crate libc;

use std::{ffi::CStr, ops::Deref};

use libc::{free, c_void, c_char};

pub trait DisposeRef {
    /// What a reference to this type represents as a C pointer.
    type RefTo;
    /// Destroy the contents at the pointer's location.
    ///
    /// This should run some variant of `libc::free(ptr)`
    unsafe fn dispose(ptr: *mut Self::RefTo) {
        free(ptr as *mut c_void);
    }
}

impl DisposeRef for str {
    type RefTo = c_char;
}

pub struct CBox<D:?Sized> where D:DisposeRef {
    pub ptr: *mut D::RefTo
}


impl<D:?Sized> CBox<D> where D:DisposeRef {
    #[inline(always)]
    /// Wrap the pointer in a `CBox`.
    pub fn new(ptr: *mut D::RefTo) -> Self {
        CBox {
            ptr
        }
    }
    #[inline(always)]
    /// Returns the internal pointer.
    pub unsafe fn as_ptr(&self) -> *mut D::RefTo {
        self.ptr
    }
    #[inline(always)]
    /// Returns the internal pointer.
    pub unsafe fn unwrap(self) -> *mut D::RefTo {
        let ptr = self.ptr;
        std::mem::forget(self);
        ptr
    }
}

impl<'a> Deref for CBox<str> {
    type Target = str;
    fn deref(&self) -> &str {
        unsafe {
            let text = CStr::from_ptr(self.ptr);
            std::str::from_utf8_unchecked(text.to_bytes())
        }

        unsafe {
            if self.ptr.is_null() {
                return "";
            } else {
                let text = CStr::from_ptr(self.ptr);
                std::str::from_utf8_unchecked(text.to_bytes())
            }
            
        }
    }
}
```

## Function Signature

```rust
pub unsafe fn from_ptr<'a>(ptr: *const i8) -> &'a CStr
```

## Related Safety Property

- The memory pointed to by ptr must contain a valid nul terminator at the end of the string.

- ptr must be valid for reads of bytes up to and including the nul terminator. This means in particular:

  - The entire memory range of this CStr must be contained within a single allocated object!
  - **ptr must be non-null even for a zero-length cstr**.

- The memory referenced by the returned CStr must not be mutated for the duration of lifetime 'a.

- The nul terminator must be within isize::MAX from ptr

## Pattern Description

In this mode, we focus on the following code elements:
1. A structure `S` containing a raw pointer.
2. An implementation of the `Deref` trait for `S<str>`, returning a `&str` object.
3. Within the `deref` function of the `Deref` implementation, using the `CStr::from_ptr` function to convert the raw pointer to a `CStr` object.

However, there is no check to determine if `ptr` is `null`, which may lead to a null pointer dereference.


